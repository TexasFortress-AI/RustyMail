---
description: 
globs: 
alwaysApply: false
---
# interface-implementations

### REST API Interface
- MUST: Implement REST endpoints using actix-web for IMAP operations
- AVOID: Mixing HTTP method semantics (e.g. using POST for read operations)
- WHY: Ensures consistent and RESTful access to IMAP functionality
- EXAMPLE: `src/api/rest.rs`

```rust
// Endpoint for folder operations
async fn create_folder(
    folder_name: String,
    imap_client: Arc<ImapClient>
) -> Result<HttpResponse, ApiError> {
    // Domain-specific folder name validation
    validate_folder_name(&folder_name)?;
    imap_client.create_folder(&folder_name).await?;
    Ok(HttpResponse::Created().finish())
}
```

### MCP Stdio Interface
- MUST: Use JSON-RPC 2.0 protocol for all MCP stdio communication
- AVOID: Custom message formats or raw stdin/stdout handling
- WHY: Provides standardized request/response pattern for mail operations
- EXAMPLE: `src/api/mcp.rs`

```rust
// MCP tool implementation
impl McpTool for McpListFoldersTool {
    fn execute(&self, _params: Value) -> Result<Value, McpPortError> {
        let folders = self.imap_client.list_folders()?;
        Ok(json!({"folders": folders}))
    }
}
```

### Server-Sent Events Interface
- MUST: Implement SSE using actix-web-lab for real-time updates
- AVOID: Long-polling or WebSocket for one-way notifications
- WHY: Efficient server-to-client push for mailbox changes
- EXAMPLE: `src/api/sse.rs`

```rust
// SSE connection handler
async fn sse_connect_handler(
    state: Data<SseState>,
) -> Sse<SseStream> {
    let (tx, rx) = mpsc::channel(100);
    state.clients.lock().await.insert(tx);
    
    Sse::new(SseStream::new(rx))
        .keep_alive(Duration::from_secs(15))
}
```

### Interface State Management
- MUST: Use atomic reference counting (Arc) for shared IMAP client state
- AVOID: Global mutable state or unsafe static variables
- WHY: Thread-safe access to IMAP client across interfaces
- EXAMPLE: `src/bin/rustymail.rs`

```rust
let imap_client = Arc::new(ImapClient::connect(config).await?);
```

### Interface Error Handling
- MUST: Map domain errors to interface-specific error types
- AVOID: Generic error messages or exposing internal errors
- WHY: Consistent error handling across interfaces
- EXAMPLE: `src/api/rest.rs`

```rust
impl From<ImapError> for ApiError {
    fn from(err: ImapError) -> Self {
        match err {
            ImapError::Auth(_) => ApiError::Unauthorized,
            ImapError::Mailbox(_) => ApiError::NotFound,
            _ => ApiError::InternalError
        }
    }
}
```

$END$