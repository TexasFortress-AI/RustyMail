# mcp-protocol

### Protocol Message Format
- MUST: Use JSON-RPC 2.0 format for all MCP messages
- AVOID: Custom message formats or non-standard JSON-RPC extensions 
- WHY: Ensures compatibility and standard error handling
- EXAMPLE: (`src/api/mcp.rs`)
```json
{
  "jsonrpc": "2.0",
  "id": "unique-id",
  "method": "imap/listFolders",
  "params": {}
}
```

### Transport Layer
- MUST: Implement both stdio and SSE transports using `Transport` trait
- AVOID: Direct socket/stream handling without transport abstraction
- WHY: Enables consistent protocol handling across transport types
- EXAMPLE: (`src/transport.rs`)

### Error Handling
- MUST: Map domain errors to standard JSON-RPC error codes:
  - -32700: Parse error
  - -32600: Invalid request
  - -32601: Method not found 
  - -32000 to -32099: IMAP-specific errors
- AVOID: Custom error codes outside JSON-RPC spec
- WHY: Maintains protocol compliance and error handling consistency
- EXAMPLE: (`src/api/mcp.rs`)

### Method Implementation
- MUST: Implement methods as `McpTool` trait objects
- AVOID: Direct IMAP calls without MCP abstraction
- WHY: Provides uniform interface for all MCP operations
- EXAMPLE: (`src/api/mcp.rs`)
```rust
#[derive(Debug)]
struct McpListFoldersTool {
    name: &'static str,
    desc: &'static str,
}
```

### State Management 
- MUST: Track client state using `SseState` for SSE transport
- AVOID: Global state or direct connection tracking
- WHY: Enables proper client lifecycle management
- EXAMPLE: (`src/api/sse.rs`)

### Testing Requirements
- MUST: Test all message formats and error cases
- MUST: Verify transport independence of protocol
- MUST: Include transport-specific edge cases
- EXAMPLE: (`src/transport_test.rs`)

### Response Formatting
- MUST: Return all results in standardized JSON-RPC response format
- AVOID: Custom response structures
- WHY: Maintains protocol consistency
- EXAMPLE: (`src/api/mcp.rs`)
```json
{
  "jsonrpc": "2.0", 
  "id": "unique-id",
  "result": { "folders": ["INBOX", "Sent"] }
}
```

$END$